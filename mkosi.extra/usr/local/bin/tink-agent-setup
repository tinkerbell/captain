#!/bin/bash
# /usr/local/bin/tink-agent-setup â€” Pull the tink-agent container image
# and extract the binary for direct execution on the host.
#
# Reads configuration from /proc/cmdline (same parameters as hook-bootkit):
#   tink_worker_image=<image>       Full image reference (takes precedence)
#   docker_registry=<registry>      Registry host (builds <registry>/tink-agent:latest)
#   registry_username=<user>        Registry auth username
#   registry_password=<pass>        Registry auth password
#   tinkerbell_tls=<bool>           Enable TLS for tink-server
#   tinkerbell_insecure_tls=<bool>  Allow insecure TLS
#   insecure_registries=<list>      Comma-separated insecure registries

set -euo pipefail

TINK_AGENT_BIN="/tink-agent"
EXTRACT_DIR="/var/lib/tink-agent"

# --- JSON logging helper ---
# Usage: log_info "message" ["key" "value" ...]
#        log_error "message" ["key" "value" ...]
_json_escape() { printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g'; }
_log() {
    local level="$1" msg="$2"
    shift 2
    local ts
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local extra=""
    while [[ $# -ge 2 ]]; do
        extra="${extra},\"$(_json_escape "$1")\":\"$(_json_escape "$2")\""
        shift 2
    done
    printf '{"time":"%s","level":"%s","msg":"%s"%s}\n' "$ts" "$level" "$(_json_escape "$msg")" "$extra"
}
log_info()  { _log "info"  "$@"; }
log_error() { _log "error" "$@"; }

# --- Parse /proc/cmdline ---
parse_cmdline() {
    local cmdline
    cmdline=$(cat /proc/cmdline)

    for param in $cmdline; do
        case "$param" in
            tink_worker_image=*)       TINK_IMAGE="${param#*=}" ;;
            docker_registry=*)         DOCKER_REGISTRY="${param#*=}" ;;
            registry_username=*)       REGISTRY_USERNAME="${param#*=}" ;;
            registry_password=*)       REGISTRY_PASSWORD="${param#*=}" ;;
            grpc_authority=*)          GRPC_AUTHORITY="${param#*=}" ;;
            worker_id=*)               WORKER_ID="${param#*=}" ;;
            tinkerbell_tls=*)          TINKERBELL_TLS="${param#*=}" ;;
            tinkerbell_insecure_tls=*) TINKERBELL_INSECURE_TLS="${param#*=}" ;;
            syslog_host=*)             SYSLOG_HOST="${param#*=}" ;;
            insecure_registries=*)     INSECURE_REGISTRIES="${param#*=}" ;;
            HTTP_PROXY=*)              HTTP_PROXY="${param#*=}" ;;
            HTTPS_PROXY=*)             HTTPS_PROXY="${param#*=}" ;;
            NO_PROXY=*)                NO_PROXY="${param#*=}" ;;
            facility=*)                FACILITY="${param#*=}" ;;
        esac
    done

    # Build image reference if not explicitly set
    if [[ -z "${TINK_IMAGE:-}" ]]; then
        local registry="${DOCKER_REGISTRY:-ghcr.io/tinkerbell}"
        TINK_IMAGE="${registry}/tink-agent:latest"
    fi

    export TINK_IMAGE DOCKER_REGISTRY REGISTRY_USERNAME REGISTRY_PASSWORD
    export GRPC_AUTHORITY WORKER_ID TINKERBELL_TLS TINKERBELL_INSECURE_TLS
    export SYSLOG_HOST HTTP_PROXY HTTPS_PROXY NO_PROXY FACILITY
}

# --- Configure insecure registries for containerd ---
configure_insecure_registries() {
    if [[ -z "${INSECURE_REGISTRIES:-}" ]]; then
        return
    fi

    log_info "configuring insecure registries" "registries" "${INSECURE_REGISTRIES}"
    local certs_dir="/etc/containerd/certs.d"

    IFS=',' read -ra REGISTRIES <<< "$INSECURE_REGISTRIES"
    for registry in "${REGISTRIES[@]}"; do
        registry=$(echo "$registry" | xargs)  # trim whitespace
        [[ -z "$registry" ]] && continue
        mkdir -p "${certs_dir}/${registry}"
        cat > "${certs_dir}/${registry}/hosts.toml" <<EOF
server = "http://${registry}"

[host."http://${registry}"]
  capabilities = ["pull", "resolve", "push"]
  skip_verify = true
EOF
        log_info "configured insecure registry" "registry" "${registry}"
    done
}

# --- Wait for containerd ---
wait_for_containerd() {
    local max_attempts=30
    local attempt=0
    local sock="/run/containerd/containerd.sock"
    log_info "waiting for containerd socket" "path" "${sock}"
    while [[ ! -S "$sock" ]]; do
        attempt=$((attempt + 1))
        if [[ $attempt -ge $max_attempts ]]; then
            log_error "containerd socket did not appear" "timeout" "${max_attempts}s"
            exit 1
        fi
        sleep 1
    done
    log_info "containerd is ready"
}

# --- Pull the tink-agent image ---
pull_image() {
    log_info "pulling tink-agent image" "image" "${TINK_IMAGE}"

    local max_attempts=5
    local attempt=0
    local wait_time=2

    # Check if the image is already present before attempting to pull
    if nerdctl images -q "${TINK_IMAGE}" 2>/dev/null | grep -q .; then
        log_info "image already present locally, skipping pull"
        return
    fi

    while true; do
        attempt=$((attempt + 1))
        if nerdctl pull -q "${TINK_IMAGE}" 2>&1; then
            log_info "image pulled successfully"
            return 0
        fi

        if [[ $attempt -ge $max_attempts ]]; then
            log_error "failed to pull image" "attempts" "${max_attempts}"
            exit 1
        fi

        log_info "pull attempt failed, retrying" "attempt" "${attempt}" "retryIn" "${wait_time}s"
        sleep "$wait_time"
        wait_time=$((wait_time * 2))
    done
}

# --- Extract the tink-agent binary from the image ---
extract_binary() {
    log_info "extracting tink-agent binary from image"
    mkdir -p "$EXTRACT_DIR"

    local tmpdir
    tmpdir=$(mktemp -d)

    # Save the image as a tar archive
    log_info "saving image to tar"
    nerdctl save "${TINK_IMAGE}" > "${tmpdir}/image.tar"
    tar -xf "${tmpdir}/image.tar" -C "${tmpdir}"

    local found=0
    local bin_paths="usr/bin/tink-agent tink-agent usr/local/bin/tink-agent usr/bin/tink-worker"

    # Docker/nerdctl format: look for layer.tar files
    while IFS= read -r layer; do
        for bin_path in $bin_paths; do
            if tar -xf "$layer" -C "$EXTRACT_DIR" "$bin_path" 2>/dev/null; then
                log_info "extracted binary from layer" "path" "${bin_path}" "layer" "$(basename "$layer")"
                found=1
                break 2
            fi
        done
    done < <(find "${tmpdir}" -name 'layer.tar' 2>/dev/null)

    # OCI format: layer blobs are gzipped tars under blobs/sha256/
    if [[ "$found" -eq 0 ]]; then
        while IFS= read -r blob; do
            for bin_path in $bin_paths; do
                if tar -xzf "$blob" -C "$EXTRACT_DIR" "$bin_path" 2>/dev/null || \
                   tar -xf "$blob" -C "$EXTRACT_DIR" "$bin_path" 2>/dev/null; then
                    log_info "extracted binary from blob" "path" "${bin_path}" "blob" "$(basename "$blob")"
                    found=1
                    break 2
                fi
            done
        done < <(find "${tmpdir}/blobs" -type f 2>/dev/null)
    fi

    if [[ "$found" -eq 1 ]]; then
        # Find the extracted binary file and install it
        local extracted
        extracted=$(find "$EXTRACT_DIR" -type f \( -name 'tink-agent' -o -name 'tink-worker' \) 2>/dev/null | head -1)
        if [[ -n "$extracted" ]]; then
            cp "$extracted" "${TINK_AGENT_BIN}"
            chmod +x "${TINK_AGENT_BIN}"
            log_info "installed tink-agent" "path" "${TINK_AGENT_BIN}"
        fi
    fi

    rm -rf "${tmpdir}"

    if [[ "$found" -eq 0 ]] || [[ ! -x "${TINK_AGENT_BIN}" ]]; then
        local layers
        layers=$(nerdctl save "${TINK_IMAGE}" | tar -tf - 2>/dev/null | head -30 || true)
        log_error "could not find tink-agent binary in container image" "layers" "${layers}"
        exit 1
    fi
}

# --- Write environment file for the systemd unit ---
write_env_file() {
    local env_file="/etc/tink-agent.env"
    log_info "writing tink-agent environment" "path" "${env_file}"

    cat > "$env_file" <<EOF
# Auto-generated by tink-agent-setup from /proc/cmdline
TINKERBELL_GRPC_AUTHORITY=${GRPC_AUTHORITY:-}
WORKER_ID=${WORKER_ID:-}
TINKERBELL_TLS=${TINKERBELL_TLS:-false}
TINKERBELL_INSECURE_TLS=${TINKERBELL_INSECURE_TLS:-false}
DOCKER_REGISTRY=${DOCKER_REGISTRY:-}
REGISTRY_USERNAME=${REGISTRY_USERNAME:-}
REGISTRY_PASSWORD=${REGISTRY_PASSWORD:-}
EOF

    [[ -n "${HTTP_PROXY:-}" ]]  && echo "HTTP_PROXY=${HTTP_PROXY}" >> "$env_file"
    [[ -n "${HTTPS_PROXY:-}" ]] && echo "HTTPS_PROXY=${HTTPS_PROXY}" >> "$env_file"
    [[ -n "${NO_PROXY:-}" ]]    && echo "NO_PROXY=${NO_PROXY}" >> "$env_file"

    chmod 600 "$env_file"
}

# --- Main ---
log_info "tink-agent-setup starting"
parse_cmdline

log_info "configuration" "image" "${TINK_IMAGE}" "grpcAuthority" "${GRPC_AUTHORITY:-}" "workerID" "${WORKER_ID:-}" "syslogHost" "${SYSLOG_HOST:-}"

wait_for_containerd
configure_insecure_registries
pull_image
extract_binary
write_env_file

log_info "tink-agent-setup complete"
